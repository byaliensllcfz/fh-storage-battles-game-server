"use strict";

var newrelic = require("newrelic");

const datastore = require("../models/datastore");
const headers = require("../config/tapps-headers");
const util = require("./util");
const uuid = require('uuid/v4');

var currentKey, previousKey;

/**
 * Security middleware.
 * Checks if the X-Tapps-Shared-Cloud-Secret header is present and if it's valid.
 * @param {Object}   req  Express request.
 * @param {Object}   res  Express response.
 * @param {Function} next Calls the next middleware / endpoint function.
 */
function security(req, res, next) {
    if (req.path === "/_ah/health") {
        // Health checks don't have the X-Tapps-Shared-Cloud-Secret so we can't apply the filter to all cases.
        next();
    } else {
        // Save the transaction ID header to the response object now so we don't have to do it later.
        var transactionId = req.header(headers["transaction-id"]) || ("message-" + uuid());
        res.set(headers["transaction-id"], transactionId);
        var cloudSharedSecret = req.header(headers["shared-cloud-secret"]);
        if (cloudSharedSecret) {
            if (cloudSharedSecret === currentKey || cloudSharedSecret === previousKey) {
                // The API accepts both the current Cloud Shared Secret generated by the gateway and the previous one,
                // in order to avoid problems with requests being rejected right after it changes.
                next();
            } else {
                // If the received key is different from the ones we have check if a new one was generated.
                datastore.read({
                    "id": "latest",
                    "kind": "SharedCloudSecret",
                    "namespace": "cloud-configs",
                    "callback": function(err, data) {
                        if (err) {
                            // Couldn't find the key in datastore
                            util.errorResponse(req, res, 500, 50000, "Failed to update server info.");
                        } else {
                            var receivedKey = data.key;
                            if (receivedKey !== currentKey) {
                                // A new key was generated, check if it matches the one received.
                                previousKey = currentKey;
                                currentKey = receivedKey;
                                if (cloudSharedSecret === currentKey || cloudSharedSecret === previousKey) {
                                    next();
                                } else {
                                    util.errorResponse(req, res, 403, 40300, "Invalid cloud secret header.");
                                }
                            } else {
                                // No new keys were generated, so the received one is invalid.
                                util.errorResponse(req, res, 403, 40300, "Invalid cloud secret header.");
                            }
                        }
                    }
                });
            }
        } else {
            util.errorResponse(req, res, 403, 40300, "Missing cloud secret header.");
        }
    }
}

/**
 * Basic 404 and 405 handler.
 * This function is only called if the request URI and method didn't match any endpoint.
 * @param {Object} req Express request.
 * @param {Object} res Express response.
 */
function notFoundHandler(req, res) {
    if (Object.prototype.hasOwnProperty.call(res.locals, "methods") && Array.isArray(res.locals.methods)) {
        util.errorResponse(req, res, 405, 40500, "This endpoint only supports " + res.locals.methods.join(", ") + ".");
    } else {
        util.errorResponse(req, res, 404, 40400, "Page not found.");
    }
}

/**
 * Error handler.
 * This function is called when an exception happens.
 * @param {Object}   err  Application error.
 * @param {Object}   req  Express request.
 * @param {Object}   res  Express response.
 * @param {Function} next Calls the next middleware / endpoint function.
 */
function errorHandler(err, req, res, next) {
    if (err.status === 400) {
        // When the body-parser middleware tries to parse a request and the body is not a json it generates an error.
        util.errorResponse(req, res, err.status, 40000, "Malformed request body.");
    } else {
        var logMessage = util.mergeResponse(req, err);
        util.logError(logMessage);
        newrelic.addCustomParameter(logMessage);
        util.errorResponse(req, res, 500, 50000, "");
    }
}

/**
 * Client Authentication.
 * Function called when the endpoint requires authentication to be used.
 * Verifies if the X-Tapps-Game-User-Id-Data or X-Tapps-Service-Account-Name are present and valid.
 * @param {String}   [userId] User ID received by the endpoint.
 * @param {Object}   req      Express request.
 * @param {Object}   res      Express response.
 * @param {Function} next     Calls the next middleware / endpoint function.
 */
function authenticate(userId, req, res, next) {
    var serviceAccountName = req.header(headers["service-account-name"]);
    if (serviceAccountName) {
        next();
    } else {
        var gameUserIdData = JSON.parse(req.header(headers["game-user-id-data"]));
        if (gameUserIdData && (gameUserIdData.uid === userId || !userId)) {
            next();
        } else {
            util.errorResponse(req, res, 403, 40300, "Header " + headers["game-user-id-data"] + " is missing or invalid.");
        }
    }
}

module.exports = {
    authenticate,
    errorHandler,
    notFoundHandler,
    security
};