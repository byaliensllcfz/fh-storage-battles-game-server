"use strict";

// The New Relic require has to be the first thing to run!
var newrelic = require("newrelic");
const bodyParser = require("body-parser");
const express = require("express");

const config = require("./config");
const datastore = require("./models/datastore");
const headers = require("./config/tapps-headers");
const util = require("./lib/util");

const app = express();
app.set("trust proxy", true);
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));

var currentKey, previousKey;

// API Endpoints
// app.use("/endpoint/route/:var", require("./file-that-contains-the-endpoint"));

// Health Check
app.use("/_ah", require("./health-check"));

// Security middleware
app.use(function(req, res, next) {
    if (req.path === "/_ah/health") {
        // Health checks don't have the X-Tapps-Shared-Cloud-Secret so we can't apply the filter to all cases.
        return next();
    } else {
        // Save the transaction ID header to the response object now so we don't have to do it later.
        var transactionId = req.header(headers["transaction-id"]);
        if (transactionId) {
            res.set(headers["transaction-id"], transactionId);
        }
        var cloudSharedSecret = req.header(headers["shared-cloud-secret"]);
        if (cloudSharedSecret) {
            if (cloudSharedSecret === currentKey || cloudSharedSecret === previousKey) {
                // The API accepts both the current Cloud Shared Secret generated by the gateway and the previous one,
                // in order to avoid problems with requests being rejected right after it changes.
                return next();
            } else {
                // If the received key is different from the ones we have check if a new one was generated.
                datastore.read({
                    "id": "latest",
                    "kind": "SharedCloudSecret",
                    "namespace": "cloud-configs",
                    "callback": function(params) {
                        if (params.error) {
                            // Couldn't find the key in datastore
                            util.errorResponse(req, res, 500, 50000, "Failed to update server info.");
                        } else {
                            var receivedKey = params.data.key;
                            if (receivedKey !== currentKey) {
                                // A new key was generated, check if it matches the one received.
                                previousKey = currentKey;
                                currentKey = receivedKey;
                                if (cloudSharedSecret === currentKey || cloudSharedSecret === previousKey) {
                                    next();
                                } else {
                                    util.errorResponse(req, res, 403, 40300, "Invalid cloud secret header.");
                                }
                            } else {
                                // No new keys were generated, so the received one is invalid.
                                util.errorResponse(req, res, 403, 40300, "Invalid cloud secret header.");
                            }
                        }
                    }
                });
            }
        } else {
            util.errorResponse(req, res, 403, 40300, "Missing cloud secret header.");
        }
    }
});

// Basic 404 and 405 handler
app.use((req, res) => {
    if (Object.prototype.hasOwnProperty.call(res.locals, "methods") && Array.isArray(res.locals.methods)) {
        util.errorResponse(req, res, 405, 40500, "This endpoint only supports " + res.locals.methods.join(", ") + ".");
    } else {
        util.errorResponse(req, res, 404, 40400, "Page not found.");
    }
});

// Error handler
app.use((err, req, res, next) => {
    if (err.status === 400) {
        // When the body-parser middleware tries to parse a request and the body is not a json it generates an error.
        util.errorResponse(req, res, err.status, 40000, "Malformed request body.");
    } else {
        var logMessage = util.mergeResponse(req, err);
        util.logError(logMessage);
        newrelic.addCustomParameter(logMessage);
        util.errorResponse(req, res, 500, 50000, "");
    }
});

if (module === require.main) {
    // Start the server
    const server = app.listen(config["PORT"], () => {
        const port = server.address().port;
        util.logNotice("App listening on port " + port);
    });
}

module.exports = app;